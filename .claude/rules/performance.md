# パフォーマンスルール

> Claude Code のパフォーマンス最適化と効率的な使用方法

---

## モデル選択の原則

### 3つのモデルの特徴

| モデル | 強み | 弱み | コスト |
|--------|------|------|--------|
| **Haiku** | 高速、低コスト | 複雑な推論が苦手 | $ |
| **Sonnet** | バランス型 | - | $$ |
| **Opus** | 最高の推論能力 | 遅い、高コスト | $$$$ |

### 選択フローチャート

```
タスクの複雑さは？
│
├─ 単純（検索、フォーマット、定型処理）
│   → Haiku
│
├─ 中程度（実装、レビュー、バグ修正）
│   → Sonnet（デフォルト）
│
└─ 複雑（設計、セキュリティ監査、難解なデバッグ）
    → Opus
```

---

## Haiku の使いどころ

### 適したタスク

```yaml
# ファイル操作
- ファイル一覧の取得
- パターンによる検索
- 単純な置換

# 情報抽出
- ログからのパターン抽出
- 定型フォーマットのパース
- 構造化データの変換

# 定型処理
- テンプレートからのコード生成
- フォーマッター的な処理
- 単純なバリデーション
```

### 使用例

```typescript
// ファイル検索
Task({
  subagent_type: "Explore",
  model: "haiku",
  prompt: "src/ 内の TODO コメントを全て列挙"
});

// 単純な変換
Task({
  subagent_type: "general-purpose",
  model: "haiku",
  prompt: "package.json の依存関係一覧を Markdown テーブルに変換"
});
```

---

## Sonnet の使いどころ（デフォルト）

### 適したタスク

```yaml
# 実装
- 新機能の実装
- バグ修正
- リファクタリング

# レビュー
- コードレビュー
- 設計レビュー
- テストレビュー

# ドキュメント
- ドキュメント作成
- コメント追加
- README 更新
```

### 使用例

```typescript
// 機能実装
Task({
  subagent_type: "org-implementer",
  prompt: "ユーザープロフィール編集機能を実装"
});

// コードレビュー
Task({
  subagent_type: "org-reviewer",
  prompt: "PR #42 の変更をレビュー"
});
```

---

## Opus の使いどころ

### 適したタスク

```yaml
# 高度な設計
- アーキテクチャ設計
- システム間の境界設計
- トレードオフ分析

# 複雑な問題解決
- 原因不明のバグ調査
- パフォーマンスボトルネック特定
- レースコンディション検出

# セキュリティ
- セキュリティ監査
- 脆弱性分析
- 脅威モデリング

# 困難なリファクタリング
- レガシーコードの理解
- 大規模な構造変更
- 複雑な依存関係の解消
```

### 使用例

```typescript
// アーキテクチャ設計
Task({
  subagent_type: "org-architect",
  model: "opus",
  prompt: "マイクロサービス分割の境界を設計。現在のモノリスから段階的に移行する計画を含む"
});

// 難解なバグ調査
Task({
  subagent_type: "org-build-fixer",
  model: "opus",
  prompt: "本番環境でのみ発生するメモリリークの原因を特定"
});
```

---

## コンテキストウィンドウの最適化

### 読み込みの効率化

```
❌ 悪い例: 全ファイルを読み込む
Read("src/components/")  // ディレクトリ全体

✅ 良い例: 必要なファイルだけ読む
Glob("src/components/**/*.tsx")  // まず一覧取得
Read("src/components/Button.tsx")  // 必要なものだけ
```

### 大きなファイルの扱い

```typescript
// 大きなファイルは分割して読む
Read({
  file_path: "src/large-file.ts",
  offset: 100,  // 100行目から
  limit: 50     // 50行だけ
});
```

### 出力の最適化

```
1. 長い出力は要約する
2. 中間結果は DASHBOARD.md に記録
3. 不要な情報は省略
```

---

## レスポンス時間の最適化

### 並列実行の活用

```typescript
// 独立したタスクは並列で
Task({ subagent_type: "org-reviewer", prompt: "src/auth/" });
Task({ subagent_type: "org-reviewer", prompt: "src/api/" });
Task({ subagent_type: "org-reviewer", prompt: "src/utils/" });
// → 3つ同時に実行、合計時間は最長のタスク分のみ
```

### バックグラウンド実行

```typescript
// 長時間タスクはバックグラウンドで
Task({
  subagent_type: "org-e2e-runner",
  prompt: "全E2Eテスト実行",
  run_in_background: true
});

// 他の作業を続行可能
```

### 早期終了

```
不要な作業は早めに切り上げる:
- 明らかにスコープ外の調査は中止
- 答えが見つかったら深掘りしない
- 完璧を求めず「十分良い」で進む
```

---

## コスト最適化

### モデル選択によるコスト削減

```
Opus 1回 ≈ Sonnet 4回 ≈ Haiku 20回

最適化の例:
1. まず Haiku で情報収集
2. Sonnet で実装
3. Opus は本当に必要な時だけ
```

### 無駄を減らす

```yaml
# 避けるべきパターン
- 同じファイルを何度も読む → キャッシュを活用
- 不要な詳細を出力 → 必要な情報だけ返す
- 全てに Opus を使う → タスクに応じて使い分け

# 推奨パターン
- 事前に必要なファイルを特定してから読む
- 回答は簡潔に
- 複雑なタスクのみ Opus を使用
```

---

## パフォーマンス監視

### 気をつけるべき兆候

```
⚠️ 遅くなっている兆候:
- 同じファイルを何度も読んでいる
- 不要な探索を繰り返している
- Opus を頻繁に使っている

⚠️ コストが増えている兆候:
- 長い出力を繰り返し生成
- 全てのタスクで Opus を使用
- 不要な並列実行
```

### 最適化のヒント

```
1. タスクを明確に定義 → 無駄な探索を防ぐ
2. 適切なモデルを選択 → コストとのバランス
3. 結果をキャッシュ → 同じ処理を繰り返さない
4. 並列実行を活用 → 待ち時間を削減
```

---

## 参考資料

- [.claude/rules/agent-coordination.md](agent-coordination.md) - エージェント協調パターン
- [.claude/commands/org-tick.md](../commands/org-tick.md) - 自動選択ロジック
